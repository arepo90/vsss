import math
import threading
from enum import IntEnum

import numpy as np
import rclpy
from rclpy.node import Node

# Mensajes: (se asume que existen, como en tu framework)
from std_msgs.msg import Int32MultiArray
from sim_msgs.msg import FieldData, LowCmd, HighCmd, ObjData, Settings
from sim_msgs.srv import Controller


# ------------------------ Parámetros globales (ajustables) ------------------------
FIXED_LATENCY = 0.01   # segundos (tiempo de retraso de paquetes)
MAX_LINEAR_SPEED = 1.0  # m/s
GOAL_TOLERANCE = 0.01   # tolerancia para considerar "llegado" al objetivo (m)
USE_LOCAL = True        # si True, convertimos velocidades a marco local del robot

# -------------------------------------------------------------------------------

class State(IntEnum):
    HALT = -1
    PAUSE = 0
    PLAY = 1


class SkillLib:
    """Funciones auxiliares: transformaciones y utilidades de velocidad."""

    @staticmethod
    def world_to_robot_frame(vec: np.ndarray, robot_theta_deg: float) -> tuple[float, float]:
        # rota vector del mundo al marco del robot (vx, vy) en m/s
        theta_rad = math.radians(robot_theta_deg)
        c = math.cos(theta_rad)
        s = math.sin(theta_rad)
        vx_world, vy_world = float(vec[0]), float(vec[1])
        # [vx_robot; vy_robot] = R(-theta) * [vx_world; vy_world]
        vx_r = c * vx_world + s * vy_world
        vy_r = -s * vx_world + c * vy_world
        return vx_r, vy_r

    @staticmethod
    def cap_speed(vx: float, vy: float, max_speed: float) -> tuple[float, float]:
        speed = math.hypot(vx, vy)
        if speed <= max_speed or speed < 1e-9:
            return vx, vy
        factor = max_speed / speed
        return vx * factor, vy * factor

    @staticmethod
    def angle_diff_deg(target_deg: float, source_deg: float) -> float:
        a = (target_deg - source_deg + 180.0) % 360.0 - 180.0
        return a


class Strat(Node):
    def __init__(self):
        super().__init__('strat_latency_comp')
        self.skills = SkillLib()

        # Subs / pubs (mismos tópicos que tu framework)
        self.field_subscriber = self.create_subscription(FieldData, 'field_data', self.gpCB, 10)
        self.settings_subscriber = self.create_subscription(Settings, 'settings', self.settingsCB, 10)
        self.active_subscriber = self.create_subscription(Int32MultiArray, 'active', self.activeCB, 10)
        self.controller_service = self.create_service(Controller, 'strat/controller', self.controllerCB)

        self.cmd_publishers = {i: self.create_publisher(LowCmd, f'/low{i}', 10) for i in range(3)}
        self.tgt_publishers = {i: self.create_publisher(HighCmd, f'/high{i}', 10) for i in range(3)}

        # estado interno
        self.cmds = [None] * 3
        self.tgts = [None] * 3
        self.timer = self.create_timer(0.05, self.send)

        self.state = State.PLAY
        self.mapping = [0, 1, 2]
        self.active = [1, 1, 1]
        self.mutex = threading.Lock()

        # Bookkeeping por robot
        self.subtask_done = [False] * 3
        self.last_target = [None] * 3

    # ---------------------- Lógica principal de movimiento ----------------------
    def move_to_point_with_latency(self, robot: ObjData, target_pos: np.ndarray, target_theta: float,
                                   latency: float = FIXED_LATENCY) -> LowCmd:
        """
        Strategy explicado:
        - Si ya dentro de GOAL_TOLERANCE -> STOP y subtask DONE.
        - Predicción si enviamos STOP ahora y la inercia hace que el robot se mueva durante 'latency':
            predicted_pos = p_now + v_now * latency
          Si predicted_pos está dentro de GOAL_TOLERANCE -> enviar STOP y subtask DONE.
        - Sino, calcular v_needed = (target - p_now) / latency  (vel que haría que tras 'latency' se llegue)
            - Si |v_needed| <= MAX_LINEAR_SPEED -> enviar v_needed (fase de aproximación fina)
            - Si |v_needed| > MAX_LINEAR_SPEED -> enviar velocidad máxima hacia el objetivo
        Notas:
        - La función siempre devuelve velocidades en marco ROBOT (vx, vy) si USE_LOCAL=True, porque
          el LowCmd espera velocidades en el marco local del robot (como en tu ejemplo).
        - dtheta se calcula para rotación y no participa en la compensación de latencia (puedes adaptarlo).
        """
        rid = int(robot.obj_id)
        p_now = np.array([robot.x, robot.y], dtype=float)
        v_now = np.array([robot.vx, robot.vy], dtype=float)
        target = np.array(target_pos, dtype=float)

        cmd = LowCmd()
        cmd.robot_id = rid
        cmd.dtheta = float(self.skills.angle_diff_deg(target_theta, robot.theta))

        # caso trivial: ya dentro de tolerancia ahora
        dist_now = np.linalg.norm(target - p_now)
        if dist_now <= GOAL_TOLERANCE:
            self.subtask_done[rid] = True
            cmd.vx = 0.0
            cmd.vy = 0.0
            return cmd

        # Predicción si enviamos STOP ahora (el robot seguirá moviéndose con su v_now durante 'latency')
        if latency < 1e-6:
            predicted_stop_pos = p_now.copy()
        else:
            predicted_stop_pos = p_now + v_now * latency

        dist_after_stop = np.linalg.norm(target - predicted_stop_pos)

        # Si con un STOP ahora quedaremos dentro de la tolerancia -> STOP y DONE
        if dist_after_stop <= GOAL_TOLERANCE:
            self.subtask_done[rid] = True
            cmd.vx = 0.0
            cmd.vy = 0.0
            return cmd

        # Si no, calculamos la velocidad necesaria para alcanzar el objetivo justo al expirar la latencia
        # v_needed_world = (target - p_now) / latency
        if latency < 1e-9:
            # latencia efectiva 0 -> nos comportamos como si quisiéramos alcanzar inmediatamente con velocidad máxima
            direction = target - p_now
            dist = np.linalg.norm(direction)
            if dist < 1e-9:
                cmd.vx, cmd.vy = 0.0, 0.0
                return cmd
            unit = direction / dist
            v_needed_world = unit * MAX_LINEAR_SPEED
        else:
            v_needed_world = (target - p_now) / float(latency)

        mag_needed = np.linalg.norm(v_needed_world)

        # Si podemos enviar una velocidad que garantice la llegada en un paquete -> la usamos (fase fina)
        if mag_needed <= MAX_LINEAR_SPEED + 1e-9:
            # enviamos exactamente v_needed_world (capear por seguridad)
            vx_cmd_world, vy_cmd_world = v_needed_world[0], v_needed_world[1]
            # marcar subtask como "no done" hasta recibir confirmación real del robot; se marcará DONE
            # cuando la siguiente predicción o la lectura del robot satisfaga la condición.
            self.subtask_done[rid] = False
        else:
            # No es posible llegar en un solo paquete: movámonos a velocidad máxima hacia el objetivo
            direction = target - p_now
            dist = np.linalg.norm(direction)
            if dist < 1e-9:
                vx_cmd_world, vy_cmd_world = 0.0, 0.0
            else:
                unit = direction / dist
                vx_cmd_world, vy_cmd_world = unit[0] * MAX_LINEAR_SPEED, unit[1] * MAX_LINEAR_SPEED
            self.subtask_done[rid] = False

        # Convertir a marco robot si es necesario y capear (aunque ya capeamos)
        if USE_LOCAL:
            vx_r, vy_r = self.skills.world_to_robot_frame(np.array([vx_cmd_world, vy_cmd_world]), robot.theta)
        else:
            vx_r, vy_r = float(vx_cmd_world), float(vy_cmd_world)

        vx_c, vy_c = self.skills.cap_speed(vx_r, vy_r, MAX_LINEAR_SPEED)

        cmd.vx = float(vx_c)
        cmd.vy = float(vy_c)
        return cmd

    # -------------------- Callbacks y utilidades ROS --------------------
    def activeCB(self, msg: Int32MultiArray):
        self.active = list(msg.data)

    def controllerCB(self, req, res):
        try:
            with self.mutex:
                self.state = State(req.state)
                # params omitted para simplicidad
            res.success = True
        except Exception:
            res.success = False
        return res

    def settingsCB(self, msg: Settings):
        global GOAL_TOLERANCE, MAX_LINEAR_SPEED, USE_LOCAL, FIXED_LATENCY
        GOAL_TOLERANCE = msg.goal_tolerance if hasattr(msg, 'goal_tolerance') else GOAL_TOLERANCE
        MAX_LINEAR_SPEED = msg.max_linear_speed if hasattr(msg, 'max_linear_speed') else MAX_LINEAR_SPEED
        USE_LOCAL = msg.local if hasattr(msg, 'local') else USE_LOCAL
        # no actualizamos FIXED_LATENCY aquí porque en tu escenario viene por configuración de red

    def send(self):
        # publica comandos guardados
        with self.mutex:
            if self.state == State.HALT:
                return
            for i, cmd in enumerate(self.cmds):
                if cmd is not None:
                    self.cmd_publishers[i].publish(cmd)
            for i, tgt in enumerate(self.tgts):
                if tgt is not None:
                    self.tgt_publishers[i].publish(tgt)

    def gpCB(self, field: FieldData):
        # Ejemplo sencillo para el robot 0; puedes extender al resto
        robot_obj: ObjData = field.team0
        robot_id = 2

        with self.mutex:
            state = self.state

        if state == State.PAUSE:
            self.cmds[robot_id] = LowCmd(robot_id=robot_id, vx=0.0, vy=0.0, dtheta=0.0)
            return
        
        print("pass")

        if robot_obj.x == 999:
            # robot no visible, cancel target
            self.cmds[robot_id] = LowCmd(robot_id=robot_id, vx=0.0, vy=0.0, dtheta=0.0)
            self.tgts[robot_id] = None
            self.subtask_done[robot_id] = False
            self.last_target[robot_id] = None
            return

        # ejemplo: mover a 0,0 con orientación 45
        target_coords = np.array([0.0, 0.0])
        target_angle = 0.0

        # Si el target cambió -> reiniciar subtask
        if self.last_target[robot_id] is None or not np.allclose(self.last_target[robot_id], target_coords):
            self.last_target[robot_id] = target_coords.copy()
            self.subtask_done[robot_id] = False

        # si subtask ya está hecha -> mantenemos stop
        if self.subtask_done[robot_id]:
            self.cmds[robot_id] = LowCmd(robot_id=robot_id, vx=0.0, vy=0.0, dtheta=0.0)
        else:
            self.cmds[robot_id] = self.move_to_point_with_latency(robot_obj, target_coords, target_angle,
                                                                  latency=FIXED_LATENCY)

        # siempre publicamos la intención de alto nivel
        self.tgts[robot_id] = HighCmd(robot_id=robot_id, skill=0, mod=0,
                                      tgt_x=float(target_coords[0]), tgt_y=float(target_coords[1]),
                                      tgt_theta=float(target_angle))



def main(args=None):
    rclpy.init(args=args)
    node = Strat()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()